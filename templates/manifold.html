<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dong Manifold ðŸŒŒ | Multi-Dimensional Chaos</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        .container { width: 100vw; height: 100vh; position: relative; }
        
        #manifoldCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        
        .hud {
            position: absolute;
            z-index: 10;
            background: rgba(0, 10, 0, 0.85);
            border: 1px solid #0f0;
            padding: 15px;
            font-size: 12px;
            backdrop-filter: blur(5px);
        }
        
        .hud.top-left { top: 10px; left: 10px; border-radius: 0 15px 15px 0; }
        .hud.top-right { top: 10px; right: 10px; border-radius: 15px 0 0 15px; text-align: right; }
        .hud.bottom-left { bottom: 10px; left: 10px; border-radius: 0 15px 15px 0; }
        .hud.center-overlay {
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #f0f;
            display: none;
            text-align: center;
        }
        
        .hud-title {
            color: #0ff;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            min-width: 200px;
        }
        
        .metric-label { color: #666; }
        .metric-value { color: #0f0; font-weight: bold; }
        .metric-value.flood { color: #f00; animation: blink 0.3s infinite; }
        .metric-value.fent { color: #0f0; text-shadow: 0 0 15px #0f0; font-size: 16px; animation: pulse 1s infinite; }
        
        .nav-link {
            display: inline-block;
            margin-top: 10px;
            padding: 5px 10px;
            background: #0f0;
            color: #000;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .nav-link:hover {
            background: #0ff;
            box-shadow: 0 0 20px #0ff;
            transform: scale(1.1);
        }
        
        .dimension-info {
            font-size: 10px;
            color: #444;
            margin-top: 5px;
            font-style: italic;
        }
        
        @keyframes blink { 50% { opacity: 0.3; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="manifoldCanvas"></canvas>
        
        <div class="hud top-left">
            <div class="hud-title">ðŸŒŒ Dong Manifold</div>
            <div class="metric-row">
                <span class="metric-label">Chaos (Z):</span>
                <span class="metric-value" id="chaosVal">0.0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Flow (X):</span>
                <span class="metric-value" id="velocityVal">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Density (Y):</span>
                <span class="metric-value" id="densityVal">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Depth (T):</span>
                <span class="metric-value" id="depthVal">0</span>
            </div>
            <a href="/" class="nav-link">â¬… Dashboard</a>
            <a href="/manifold3d" class="nav-link">ðŸŒ  3D</a>
            <a href="/fentviz" class="nav-link" style="background: linear-gradient(90deg, #f00, #ff0, #0f0); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">ðŸŒ¿ FENT</a>
            <div class="dimension-info">X: Chat | Y: Pizza | Z: Chaos | T: Time</div>
        </div>
        
        <div class="hud top-right">
            <div class="hud-title">ðŸ“Š Higher Dimensions</div>
            <div class="metric-row">
                <span class="metric-label">Chat (5m):</span>
                <span class="metric-value" id="chat5Val">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Door (10m):</span>
                <span class="metric-value" id="door10Val">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Pizza (Y):</span>
                <span class="metric-value" id="pizzaVal">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Glizz (W):</span>
                <span class="metric-value" id="glizzVal">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Dong (D):</span>
                <span class="metric-value" id="dongVal">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Dick+Cock (V):</span>
                <span class="metric-value" id="dongVariantVal">0</span>
            </div>
            <div class="dimension-info">W: Glizz | D: Dong | V: Variants | T: Door Flux</div>
        </div>
        
        <div class="hud bottom-left">
            <div class="hud-title">ðŸŒ€ Active Entities</div>
            <div class="metric-value" id="particleCount">0</div>
            <div class="dimension-info">Particles + Rings + Portals</div>
        </div>
        
        <div class="hud center-overlay" id="portalOverlay">
            <div class="hud-title">ðŸŒ€ DIMENSIONAL PORTAL ACTIVE</div>
            <div>Chaos exceeds 42069</div>
            <div style="font-size: 24px; margin: 10px;">ðŸŒ¿ FENTHOUSE ACHIEVED ðŸŒ¿</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('manifoldCanvas');
        const ctx = canvas.getContext('2d');
        let lastData = null;
        let trajectory = [];
        let particles = [];
        let pulseRings = [];
        let dimensionalPortals = [];
        let lastChaos = 0;
        let frameCount = 0;
        let centerX, centerY;
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Multi-dimensional chaos mapping - EXPANDED DIMENSIONS
        function getChaosDimensions(chaos, chat, door, pizza, glizz, dong, dongData, time) {
            return {
                x: centerX + (chat / 50) * Math.cos(time * 0.001) * 100,
                y: centerY - (pizza / 20) * Math.sin(time * 0.001) * 100,
                z: chaos, // Primary Z-axis: Chaos magnitude
                w: glizz * 10, // W-dimension: Glizz intensity (hotdogs)
                t: door * 5, // T-dimension: Temporal door flux
                dongAxis: dong / 10, // D-dimension: Dong density
                dongVariant: (dongData?.dick || 0) + (dongData?.cock || 0), // V-dimension: Variant chaos
                depth: Math.min(1, chaos / 1000), // 0-1 depth factor
                rotation: time * 0.1 + chaos * 0.01,
                hyperFold: Math.sin(time * 0.05) * (glizz + dong) / 50 // Hyperdimensional folding
            };
        }
        
        function getChaosColor(score) {
            if (score >= 42069) return '#0f0'; // Fenthouse green
            if (score > 5000) return `hsl(${Date.now() / 10 % 360}, 100%, 50%)`; // Rainbow
            if (score > 1000) return '#f0f';
            if (score > 500) return '#f00';
            if (score > 100) return '#f80';
            if (score > 50) return '#ff0';
            return '#0f0';
        }
        
        function getParticleColor(chaos) {
            const hue = (Date.now() / 20 + chaos * 0.5) % 360;
            return `hsl(${hue}, 80%, 60%)`;
        }
        
        class Particle {
            constructor(x, y, z, chaos) {
                this.x = x;
                this.y = y;
                this.z = z; // Depth (0-1)
                this.vx = (Math.random() - 0.5) * 3 * (1 + chaos/100);
                this.vy = (Math.random() - 0.5) * 3 * (1 + chaos/100);
                this.vz = (Math.random() - 0.5) * 0.02; // Depth velocity
                this.life = 1;
                this.decay = 0.005 + (chaos / 100000);
                this.size = 2 + (chaos / 50);
                this.chaos = chaos;
            }
            
            update(centerGravity) {
                this.x += this.vx;
                this.y += this.vy;
                this.z = Math.max(0, Math.min(1, this.z + this.vz));
                this.life -= this.decay;
                
                // Gravity toward chaos center
                const dx = centerGravity.x - this.x;
                const dy = centerGravity.y - this.y;
                this.vx += dx * 0.001 * this.chaos / 100;
                this.vy += dy * 0.001 * this.chaos / 100;
                
                // Friction
                this.vx *= 0.98;
                this.vy *= 0.98;
            }
            
            draw(ctx) {
                const depthScale = 0.5 + this.z * 0.5;
                const alpha = this.life * depthScale;
                const size = this.size * depthScale;
                
                ctx.globalAlpha = alpha;
                ctx.fillStyle = getParticleColor(this.chaos);
                ctx.shadowBlur = 15 * depthScale;
                ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }
        
        class PulseRing {
            constructor(x, y, chaos, depth = 0) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.maxRadius = 100 + chaos * 0.3;
                this.life = 1;
                this.decay = 0.015;
                this.chaos = chaos;
                this.z = depth;
                this.lineWidth = 2 + chaos / 50;
                this.rotation = Date.now() * 0.001;
            }
            
            update() {
                this.radius += 2 + this.chaos / 100;
                this.life -= this.decay;
                this.lineWidth *= 0.98;
                this.rotation += 0.02;
            }
            
            draw(ctx) {
                const depthScale = 0.5 + this.z * 0.5;
                const alpha = this.life * 0.4 * depthScale;
                
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = getChaosColor(this.chaos);
                ctx.lineWidth = this.lineWidth * depthScale;
                ctx.shadowBlur = 20 * depthScale;
                ctx.shadowColor = ctx.strokeStyle;
                
                // Draw rotating hexagon for chaos > 100
                if (this.chaos > 100) {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = this.rotation + (i * Math.PI / 3);
                        const x = this.x + Math.cos(angle) * this.radius;
                        const y = this.y + Math.sin(angle) * this.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }
        
        class DimensionalPortal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = 200;
                this.rotation = 0;
                this.life = 1;
            }
            
            update() {
                if (this.radius < this.maxRadius) this.radius += 5;
                this.rotation += 0.1;
                this.life -= 0.001;
            }
            
            draw(ctx) {
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                gradient.addColorStop(0, 'transparent');
                gradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.2)');
                gradient.addColorStop(1, 'transparent');
                
                ctx.globalAlpha = this.life;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Rotating portal rings
                for (let i = 0; i < 3; i++) {
                    ctx.strokeStyle = `hsl(${(Date.now() / 10 + i * 120) % 360}, 100%, 50%)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const r = this.radius * (0.5 + i * 0.2);
                    for (let a = 0; a < Math.PI * 2; a += 0.1) {
                        const x = this.x + Math.cos(a + this.rotation + i) * r;
                        const y = this.y + Math.sin(a + this.rotation + i) * r;
                        if (a === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
        }
        
        function drawDimensionalGrid(time, activity) {
            ctx.strokeStyle = `rgba(0, 50, 0, ${0.2 + activity / 100})`;
            ctx.lineWidth = 1;
            
            // Perspective grid lines
            for (let i = -10; i <= 10; i++) {
                const offset = i * 50 + Math.sin(time * 0.001 + i) * 10;
                ctx.beginPath();
                ctx.moveTo(centerX + offset * 0.2, 0);
                ctx.lineTo(centerX + offset * 2, canvas.height);
                ctx.stroke();
            }
            
            for (let i = -5; i <= 5; i++) {
                const y = centerY + i * 40 + Math.cos(time * 0.001 + i) * 5;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function drawChaosPoint(dims) {
            const { x, y, z, depth, rotation } = dims;
            const color = getChaosColor(z);
            const radius = 15 + z / 10;
            
            // Add to trajectory
            trajectory.push({x, y, z, depth, time: Date.now()});
            if (trajectory.length > 50) trajectory.shift();
            
            // Check for major chaos events
            if (z > lastChaos + 20 && z > 100) {
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(x, y, depth, z));
                }
                pulseRings.push(new PulseRing(x, y, z, depth));
            }
            
            // Check for Fenthouse
            if (z >= 42069 && dimensionalPortals.length === 0) {
                dimensionalPortals.push(new DimensionalPortal(x, y));
                document.getElementById('portalOverlay').style.display = 'block';
            } else if (z < 42069) {
                dimensionalPortals = [];
                document.getElementById('portalOverlay').style.display = 'none';
            }
            
            // Regular particle spawn
            if (Math.random() < z / 1000) {
                particles.push(new Particle(x, y, depth * Math.random(), z));
            }
            
            // Periodic pulses based on activity
            if (frameCount % Math.max(10, 60 - Math.floor(z / 50)) === 0) {
                pulseRings.push(new PulseRing(x, y, z, depth));
            }
            
            // Draw chaos core
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            // Glow layers
            for (let i = 3; i >= 0; i--) {
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.3 - i * 0.05;
                ctx.shadowBlur = 40 + i * 10;
                ctx.shadowColor = color;
                ctx.beginPath();
                if (z > 500) {
                    // Star shape for high chaos
                    for (let j = 0; j < 8; j++) {
                        const angle = (j / 8) * Math.PI * 2;
                        const r = j % 2 === 0 ? radius + i * 5 : radius * 0.5 + i * 5;
                        const px = Math.cos(angle) * r;
                        const py = Math.sin(angle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                } else {
                    ctx.arc(0, 0, radius + i * 5, 0, Math.PI * 2);
                }
                ctx.fill();
            }
            
            // Inner core
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px monospace';
            ctx.fillText(`âš¡${z.toFixed(0)}`, x + 30, y);
            
            lastChaos = z;
            return {x, y};
        }
        
        function drawTrajectory() {
            if (trajectory.length < 2) return;
            
            for (let i = 0; i < trajectory.length - 1; i++) {
                const p1 = trajectory[i];
                const p2 = trajectory[i + 1];
                const alpha = (i / trajectory.length) * 0.5;
                const depthScale = 0.5 + p1.z * 0.5;
                
                ctx.strokeStyle = getChaosColor(p1.z);
                ctx.globalAlpha = alpha;
                ctx.lineWidth = 2 * depthScale;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }
        
        function animate() {
            const time = Date.now();
            frameCount++;
            
            // Fade background for trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            let dims = { x: centerX, y: centerY, z: 0, depth: 0, rotation: 0 };
            
            if (lastData) {
                dims = getChaosDimensions(
                    lastData.chaos_score,
                    lastData.chat_velocity_5min,
                    lastData.door_events_10min,
                    lastData.pizza_count,
                    time
                );
                
                const totalActivity = lastData.chat_velocity_5min + lastData.door_events_10min;
                drawDimensionalGrid(time, totalActivity);
                drawTrajectory();
            }
            
            // Update and draw dimensional portals
            dimensionalPortals = dimensionalPortals.filter(portal => {
                portal.update();
                portal.draw(ctx);
                return portal.life > 0;
            });
            
            // Update and draw pulse rings
            pulseRings = pulseRings.filter(ring => {
                ring.update();
                ring.draw(ctx);
                return ring.life > 0;
            });
            
            // Update and draw particles
            particles = particles.filter(p => {
                p.update(dims);
                p.draw(ctx);
                return p.life > 0;
            });
            
            // Draw chaos point
            drawChaosPoint(dims);
            
            // Update displays
            document.getElementById('particleCount').textContent = 
                particles.length + pulseRings.length + dimensionalPortals.length;
            
            requestAnimationFrame(animate);
        }
        
        function updateMetrics() {
            if (!lastData) return;
            
            const chaos = lastData.chaos_score;
            
            document.getElementById('chaosVal').textContent = chaos.toFixed(1);
            document.getElementById('chaosVal').className = 'metric-value ' + 
                (chaos >= 42069 ? 'fent' : chaos > 80 ? 'flood' : '');
            
            // Calculate dimensional metrics
            const flow = lastData.chat_velocity_5min + lastData.door_events_10min;
            const density = lastData.pizza_count + lastData.glizz_count + lastData.dong_count;
            const depth = trajectory.length;
            
            document.getElementById('velocityVal').textContent = flow;
            document.getElementById('densityVal').textContent = density > 1000 ? (density/1000).toFixed(1) + 'k' : density;
            document.getElementById('depthVal').textContent = depth;
            
            document.getElementById('chat5Val').textContent = lastData.chat_velocity_5min;
            document.getElementById('door10Val').textContent = lastData.door_events_10min;
            document.getElementById('pizzaVal').textContent = lastData.pizza_count;
            document.getElementById('glizzVal').textContent = lastData.glizz_count;
        }
        
        async function fetchMetrics() {
            try {
                const response = await fetch('/api/metrics');
                lastData = await response.json();
                updateMetrics();
            } catch (err) {
                console.error('Fetch error:', err);
            }
        }
        
        animate();
        fetchMetrics();
        setInterval(fetchMetrics, 3000);
    </script>
</body>
</html>
