<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dong Manifold 3D ðŸŒŒ | WebGL Chaos Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .hud {
            position: absolute;
            z-index: 10;
            background: rgba(0, 10, 0, 0.85);
            border: 1px solid #0f0;
            padding: 15px;
            font-size: 12px;
            backdrop-filter: blur(5px);
            pointer-events: none;
        }
        .hud.top-left { top: 10px; left: 10px; border-radius: 0 15px 15px 0; }
        .hud-title {
            color: #0ff;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            min-width: 200px;
        }
        .metric-value { color: #0f0; font-weight: bold; }
        .nav-link {
            pointer-events: auto;
            display: inline-block;
            margin-top: 10px;
            padding: 5px 10px;
            background: #0f0;
            color: #000;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
        }
        .controls-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #666;
            font-size: 11px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="hud top-left">
        <div class="hud-title">ðŸŒŒ Dong Manifold 3D</div>
        <div class="metric-row">
            <span>Chaos:</span>
            <span class="metric-value" id="chaosVal">0.0</span>
        </div>
        <div class="metric-row">
            <span>Particles:</span>
            <span class="metric-value" id="particleCount">0</span>
        </div>
        <a href="/" class="nav-link">â¬… Dashboard</a>
        <a href="/manifold" class="nav-link">2D Version</a>
    </div>
    
    <div class="controls-info">
        Left Click: Rotate | Right Click: Pan | Scroll: Zoom<br>
        X=Chat Velocity | Y=Pizza | Z=Chaos
    </div>

    <script>
        // Three.js setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 20, 30);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0x00ff00, 1, 100);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);
        
        const pointLight2 = new THREE.PointLight(0xff00ff, 0.5, 100);
        pointLight2.position.set(0, -10, 0);
        scene.add(pointLight2);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(100, 50, 0x112211, 0x051105);
        scene.add(gridHelper);
        
        // Chaos particle system
        const particleCount = 1000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 50;
            positions[i * 3 + 1] = Math.random() * 20;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
            
            colors[i * 3] = 0;
            colors[i * 3 + 1] = 1;
            colors[i * 3 + 2] = 0;
            
            sizes[i] = Math.random() * 0.5;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        
        // Chaos core sphere
        const coreGeometry = new THREE.SphereGeometry(2, 32, 32);
        const coreMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ff00,
            emissive: 0x004400,
            shininess: 100,
            transparent: true,
            opacity: 0.9
        });
        const chaosCore = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(chaosCore);
        
        // Trail line
        const trailGeometry = new THREE.BufferGeometry();
        const trailMaterial = new THREE.LineBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.5,
            linewidth: 2
        });
        const trailLine = new THREE.Line(trailGeometry, trailMaterial);
        scene.add(trailLine);
        
        let lastData = null;
        let trailPoints = [];
        let time = 0;
        
        function getChaosColor(score) {
            if (score >= 42069) return new THREE.Color(0x00ff00);
            if (score > 5000) return new THREE.Color(0xff00ff);
            if (score > 1000) return new THREE.Color(0xff00ff);
            if (score > 500) return new THREE.Color(0xff0000);
            if (score > 100) return new THREE.Color(0xff8800);
            if (score > 50) return new THREE.Color(0xffff00);
            return new THREE.Color(0x00ff00);
        }
        
        function updateChaosVisualization() {
            if (!lastData) return;
            
            const chaos = lastData.chaos_score;
            const chat = lastData.chat_velocity_5min;
            const pizza = lastData.pizza_count;
            
            // Map to 3D coordinates
            const x = (chat / 20) - 25;
            const y = (pizza / 100) - 10;
            const z = (chaos / 100) - 25;
            
            // Update core position
            chaosCore.position.set(x, y, z);
            
            // Update core color and size based on chaos
            const color = getChaosColor(chaos);
            chaosCore.material.color = color;
            chaosCore.material.emissive = color.clone().multiplyScalar(0.3);
            chaosCore.scale.setScalar(1 + chaos / 100);
            
            // Update light color
            pointLight.color = color;
            
            // Update trail
            trailPoints.push(new THREE.Vector3(x, y, z));
            if (trailPoints.length > 50) trailPoints.shift();
            trailLine.geometry.setFromPoints(trailPoints);
            
            // Update particles around chaos point
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            
            for (let i = 0; i < particleCount; i++) {
                // Particles swirl around chaos center
                const angle = time * 0.5 + (i / particleCount) * Math.PI * 2;
                const radius = 5 + Math.sin(time + i * 0.1) * 3;
                const height = Math.sin(time * 2 + i * 0.05) * (chaos / 50);
                
                positions[i * 3] = x + Math.cos(angle) * radius;
                positions[i * 3 + 1] = y + height;
                positions[i * 3 + 2] = z + Math.sin(angle) * radius;
                
                // Color based on height and chaos
                const particleColor = getChaosColor(chaos + height * 10);
                colors[i * 3] = particleColor.r;
                colors[i * 3 + 1] = particleColor.g;
                colors[i * 3 + 2] = particleColor.b;
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            
            // Update HUD
            document.getElementById('chaosVal').textContent = chaos.toFixed(1);
            document.getElementById('particleCount').textContent = particleCount;
        }
        
        async function fetchMetrics() {
            try {
                const response = await fetch('/api/metrics');
                lastData = await response.json();
            } catch (err) {
                console.error('Fetch error:', err);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            controls.update();
            updateChaosVisualization();
            
            // Rotate grid slowly
            gridHelper.rotation.y += 0.001;
            
            // Camera slowly orbits if not user-controlled
            // camera.position.x = Math.sin(time * 0.1) * 40;
            // camera.position.z = Math.cos(time * 0.1) * 40;
            // camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        fetchMetrics();
        animate();
        setInterval(fetchMetrics, 5000);
    </script>
</body>
</html>
