<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dong Manifold ðŸŒŒ | Chaos Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #050508;
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        .container { width: 100vw; height: 100vh; position: relative; }
        
        #manifoldCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        
        .hud {
            position: absolute;
            z-index: 10;
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #0f0;
            padding: 15px;
            font-size: 12px;
        }
        
        .hud.top-left { top: 10px; left: 10px; border-radius: 0 15px 15px 0; }
        .hud.top-right { top: 10px; right: 10px; border-radius: 15px 0 0 15px; text-align: right; }
        .hud.bottom-left { bottom: 10px; left: 10px; border-radius: 0 15px 15px 0; }
        
        .hud-title {
            color: #0ff;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            min-width: 200px;
        }
        
        .metric-label { color: #888; }
        .metric-value { color: #0f0; font-weight: bold; }
        .metric-value.flood { color: #f00; animation: blink 0.3s infinite; }
        .metric-value.fent { color: #0f0; text-shadow: 0 0 10px #0f0; font-size: 16px; }
        
        .nav-link {
            display: inline-block;
            margin-top: 10px;
            padding: 5px 10px;
            background: #0f0;
            color: #000;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .nav-link:hover {
            background: #0ff;
            box-shadow: 0 0 15px #0ff;
        }
        
        @keyframes blink { 50% { opacity: 0.3; } }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="manifoldCanvas"></canvas>
        
        <div class="hud top-left">
            <div class="hud-title">ðŸŒŒ Dong Manifold</div>
            <div class="metric-row">
                <span class="metric-label">Chaos:</span>
                <span class="metric-value" id="chaosVal">0.0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Velocity:</span>
                <span class="metric-value" id="velocityVal">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Direction:</span>
                <span class="metric-value" id="directionVal">â†’</span>
            </div>
            <a href="/" class="nav-link">â¬… Dashboard</a>
        </div>
        
        <div class="hud top-right">
            <div class="hud-title">ðŸ“Š Real-time Metrics</div>
            <div class="metric-row">
                <span class="metric-label">Chat (5m):</span>
                <span class="metric-value" id="chat5Val">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Door (10m):</span>
                <span class="metric-value" id="door10Val">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Pizza:</span>
                <span class="metric-value" id="pizzaVal">0</span>
            </div>
        </div>
        
        <div class="hud bottom-left">
            <div class="hud-title">ðŸŽ¯ Active Particles</div>
            <div class="metric-value" id="particleCount">0</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('manifoldCanvas');
        const ctx = canvas.getContext('2d');
        let lastData = null;
        let trajectory = [];
        let particles = [];
        let pulseRings = [];
        let lastChaos = 0;
        let animationId;
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        function logScale(value, maxVal = 1000) {
            if (value <= 0) return 0;
            return Math.log10(value + 1) / Math.log10(maxVal + 1);
        }
        
        function getChaosClass(score) {
            if (score >= 42069) return 'fent';
            if (score > 1000) return 'heatdeath';
            if (score > 95) return 'apocalyptic';
            if (score > 80) return 'demonic';
            if (score > 60) return 'chaotic';
            if (score > 40) return 'active';
            return 'calm';
        }
        
        function getChaosColor(score) {
            if (score >= 42069) return '#0f0';
            if (score > 1000) return '#f0f';
            if (score > 500) return '#f0f';
            if (score > 100) return '#f00';
            if (score > 80) return '#f08';
            if (score > 60) return '#f80';
            if (score > 40) return '#ff0';
            return '#0f0';
        }
        
        class Particle {
            constructor(x, y, chaos) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 1;
                this.decay = 0.01 + Math.random() * 0.02;
                this.size = 2 + Math.random() * 4;
                this.chaos = chaos;
                this.color = getChaosColor(chaos);
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.vx *= 0.98;
                this.vy *= 0.98;
            }
            
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }
        
        class PulseRing {
            constructor(x, y, chaos) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.maxRadius = 100 + chaos * 0.5;
                this.life = 1;
                this.decay = 0.02;
                this.color = getChaosColor(chaos);
                this.lineWidth = 3;
            }
            
            update() {
                this.radius += 3;
                this.life -= this.decay;
                this.lineWidth *= 0.98;
            }
            
            draw(ctx) {
                ctx.globalAlpha = this.life * 0.5;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.lineWidth;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }
        
        function drawDynamicGrid() {
            const time = Date.now() / 1000;
            ctx.strokeStyle = '#112211';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const offset = (time * 10) % gridSize;
            
            for (let x = offset; x < canvas.width; x += gridSize) {
                const wave = Math.sin((x + time * 50) / 100) * 5;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = offset; y < canvas.height; y += gridSize) {
                const wave = Math.cos((y + time * 30) / 100) * 5;
                ctx.beginPath();
                ctx.moveTo(0, y + wave);
                ctx.lineTo(canvas.width, y + wave);
                ctx.stroke();
            }
        }
        
        function drawRegions() {
            const w = canvas.width, h = canvas.height;
            const time = Date.now() / 1000;
            
            // Animated regions
            ctx.fillStyle = `rgba(0, 255, 136, ${0.05 + Math.sin(time) * 0.02})`;
            ctx.fillRect(0, h*0.8, w*0.2, h*0.2);
            
            ctx.fillStyle = `rgba(255, 255, 0, ${0.05 + Math.sin(time + 1) * 0.02})`;
            ctx.fillRect(w*0.2, h*0.6, w*0.2, h*0.25);
            
            ctx.fillStyle = `rgba(255, 136, 0, ${0.05 + Math.sin(time + 2) * 0.02})`;
            ctx.fillRect(w*0.4, h*0.4, w*0.2, h*0.25);
            
            ctx.fillStyle = `rgba(255, 0, 136, ${0.05 + Math.sin(time + 3) * 0.02})`;
            ctx.fillRect(w*0.6, h*0.2, w*0.2, h*0.25);
            
            ctx.fillStyle = `rgba(255, 0, 0, ${0.05 + Math.sin(time + 4) * 0.02})`;
            ctx.fillRect(w*0.8, 0, w*0.2, h*0.25);
        }
        
        function drawTrail() {
            if (trajectory.length < 2) return;
            
            ctx.lineWidth = 3;
            for (let i = 0; i < trajectory.length - 1; i++) {
                const alpha = i / trajectory.length;
                ctx.strokeStyle = `rgba(255, 0, 255, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.moveTo(trajectory[i].x, trajectory[i].y);
                ctx.lineTo(trajectory[i + 1].x, trajectory[i + 1].y);
                ctx.stroke();
            }
        }
        
        function drawChaosPoint(chaos, chat, pizza) {
            const x = Math.min(canvas.width * 0.9, Math.max(50, 50 + logScale(chat, 1000) * canvas.width * 0.8));
            const y = Math.min(canvas.height * 0.9, Math.max(50, canvas.height * 0.9 - logScale(pizza, 10000000000) * canvas.height * 0.8));
            
            // Update trajectory
            trajectory.push({x, y, chaos, time: Date.now()});
            if (trajectory.length > 100) trajectory.shift();
            
            // Check for chaos increase to spawn particles
            if (chaos > lastChaos + 5) {
                // Burst of particles
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(x, y, chaos));
                }
                // Add pulse ring
                pulseRings.push(new PulseRing(x, y, chaos));
            }
            
            // Regular particle spawn based on chaos level
            if (Math.random() < chaos / 500) {
                particles.push(new Particle(x, y, chaos));
            }
            
            // Periodic pulse rings
            if (Date.now() % 60 === 0) {
                pulseRings.push(new PulseRing(x, y, chaos));
            }
            
            const color = getChaosColor(chaos);
            const radius = chaos > 100 ? 30 : 10 + chaos / 5;
            
            // Glow
            ctx.shadowBlur = 30;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Inner core
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // Label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px monospace';
            ctx.fillText(`âš¡${chaos.toFixed(0)}`, x + 25, y);
            
            lastChaos = chaos;
            return {x, y};
        }
        
        function animate() {
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawDynamicGrid();
            drawRegions();
            drawTrail();
            
            // Update and draw pulse rings
            pulseRings = pulseRings.filter(ring => {
                ring.update();
                ring.draw(ctx);
                return ring.life > 0;
            });
            
            // Update and draw particles
            particles = particles.filter(p => {
                p.update();
                p.draw(ctx);
                return p.life > 0;
            });
            
            // Draw chaos point
            if (lastData) {
                drawChaosPoint(lastData.chaos_score, lastData.chat_velocity_5min, lastData.pizza_count);
            }
            
            // Update particle count display
            document.getElementById('particleCount').textContent = particles.length;
            
            animationId = requestAnimationFrame(animate);
        }
        
        function updateMetrics() {
            if (!lastData) return;
            
            const chaos = lastData.chaos_score;
            const chaosClass = getChaosClass(chaos);
            
            document.getElementById('chaosVal').textContent = chaos.toFixed(1);
            document.getElementById('chaosVal').className = 'metric-value ' + (chaosClass === 'fent' ? 'fent' : chaos > 80 ? 'flood' : '');
            document.getElementById('chat5Val').textContent = lastData.chat_velocity_5min;
            document.getElementById('door10Val').textContent = lastData.door_events_10min;
            document.getElementById('pizzaVal').textContent = lastData.pizza_count > 1000000 ? (lastData.pizza_count / 1000000).toFixed(1) + 'M' : lastData.pizza_count;
            
            if (trajectory.length > 1) {
                const recent = trajectory.slice(-10);
                const dx = recent[recent.length - 1].x - recent[0].x;
                const dy = recent[recent.length - 1].y - recent[0].y;
                const velocity = Math.sqrt(dx*dx + dy*dy) * 10; // Scale up for visibility
                document.getElementById('velocityVal').textContent = velocity.toFixed(1);
                
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                let arrow = 'â†’';
                if (angle > 45 && angle < 135) arrow = 'â†“';
                else if (angle >= 135 || angle < -135) arrow = 'â†';
                else if (angle >= -135 && angle < -45) arrow = 'â†‘';
                document.getElementById('directionVal').textContent = arrow;
            }
        }
        
        async function fetchMetrics() {
            try {
                const response = await fetch('/api/metrics');
                lastData = await response.json();
                updateMetrics();
            } catch (err) {
                console.error('Fetch error:', err);
            }
        }
        
        animate();
        fetchMetrics();
        setInterval(fetchMetrics, 3000);
    </script>
</body>
</html>
