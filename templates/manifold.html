<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dong Manifold üçÜ | Flood Control Center</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #050508;
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        .container { width: 100vw; height: 100vh; position: relative; }
        
        /* Canvas for high-performance rendering */
        #manifoldCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        
        /* Overlay UI */
        .hud {
            position: absolute;
            z-index: 10;
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #0f0;
            padding: 15px;
            font-size: 12px;
        }
        
        .hud.top-left { top: 10px; left: 10px; border-radius: 0 15px 15px 0; }
        .hud.top-right { top: 10px; right: 10px; border-radius: 15px 0 0 15px; text-align: right; }
        .hud.flood-alert {
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid #f00;
            background: rgba(50, 0, 0, 0.95);
            color: #f00;
            font-size: 24px;
            display: none;
            animation: pulse-red 0.5s infinite;
        }
        
        .hud-title {
            color: #0ff;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            min-width: 200px;
        }
        
        .metric-label { color: #888; }
        .metric-value { color: #0f0; font-weight: bold; }
        .metric-value.flood { color: #f00; animation: blink 0.3s infinite; }
        .metric-value.fent { color: #0f0; text-shadow: 0 0 10px #0f0; font-size: 16px; }
        
        /* Chaos Level Indicator */
        .chaos-bar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #0f0;
            padding: 15px 30px;
            border-radius: 25px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .bar-container {
            width: 300px;
            height: 20px;
            background: #111;
            border: 1px solid #333;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.3s ease, background 0.3s ease;
        }
        .bar-fill.calm { background: #0f0; }
        .bar-fill.active { background: #ff0; }
        .bar-fill.chaotic { background: #f80; }
        .bar-fill.demonic { background: #f08; }
        .bar-fill.apocalyptic { background: #f00; }
        .bar-fill.heatdeath { 
            background: linear-gradient(90deg, #f00, #f0f, #00f, #0ff, #0f0, #ff0, #f00);
            background-size: 200% 100%;
            animation: rainbow-fill 2s linear infinite;
        }
        
        .chaos-text {
            font-size: 18px;
            font-weight: bold;
        }
        
        /* Legend overlay */
        .legend-overlay {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0f0;
            padding: 10px;
            border-radius: 10px;
            font-size: 11px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 3px 0;
        }
        
        .legend-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
        }
        
        @keyframes pulse-red {
            0%, 100% { opacity: 1; box-shadow: 0 0 20px #f00; }
            50% { opacity: 0.7; box-shadow: 0 0 50px #f00; }
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        @keyframes rainbow-fill {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="manifoldCanvas"></canvas>
        
        <!-- Top Left: Real-time Metrics -->
        <div class="hud top-left">
            <div class="hud-title">üìä DONGOMETER METRICS</div>
            <div class="metric-row">
                <span class="metric-label">Chaos:</span>
                <span class="metric-value" id="chaosVal">Loading...</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">5min Msgs:</span>
                <span class="metric-value" id="chat5Val">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">10min Doors:</span>
                <span class="metric-value" id="door10Val">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Pizzas:</span>
                <span class="metric-value" id="pizzaVal">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Status:</span>
                <span class="metric-value" id="statusVal">-</span>
            </div>
        </div>
        
        <!-- Top Right: Trajectory Analysis -->
        <div class="hud top-right">
            <div class="hud-title">üéØ TRAJECTORY</div>
            <div class="metric-row">
                <span class="metric-label">Velocity:</span>
                <span class="metric-value" id="velocityVal">0 msg/min</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Direction:</span>
                <span class="metric-value" id="directionVal">‚Üí</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Flood Risk:</span>
                <span class="metric-value" id="floodRiskVal">LOW</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Time to Fent:</span>
                <span class="metric-value" id="timeToFentVal">‚àû</span>
            </div>
        </div>
        
        <!-- Center: Flood Alert (hidden by default) -->
        <div class="hud flood-alert" id="floodAlert">
            üö® DONG FLOOD DETECTED üö®<br>
            <span style="font-size: 14px;">Buffer at capacity - chaos overflowing</span>
        </div>
        
        <!-- Bottom Center: Chaos Level Bar -->
        <div class="chaos-bar">
            <span>CHAOS LEVEL</span>
            <div class="bar-container">
                <div class="bar-fill" id="chaosBar" style="width: 0%"></div>
            </div>
            <span class="chaos-text" id="chaosBig">0.0</span>
        </div>
        
        <!-- Legend -->
        <div class="legend-overlay">
            <div class="metric-row">
                <span class="metric-label">X: Chat Velocity</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Y: Pizza Density</span>
            </div>
            <div class="legend-item"><div class="legend-dot" style="background:#0f0"></div> üò¥ 0-20</div>
            <div class="legend-item"><div class="legend-dot" style="background:#ff0"></div> ‚ö° 21-40</div>
            <div class="legend-item"><div class="legend-dot" style="background:#f80"></div> üçï 41-60</div>
            <div class="legend-item"><div class="legend-dot" style="background:#f08"></div> üëø 61-80</div>
            <div class="legend-item"><div class="legend-dot" style="background:#f00"></div> ‚ò†Ô∏è 81-100</div>
            <div class="legend-item"><div class="legend-dot" style="background:linear-gradient(90deg,#f00,#ff0,#0f0,#0ff,#00f,#f0f)"></div> ‚àû 100+</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('manifoldCanvas');
        const ctx = canvas.getContext('2d');
        let lastData = null;
        let trajectory = [];
        let maxPoints = 500;
        
        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Logarithmic scale for huge chaos values
        function logScale(value, maxVal = 10000) {
            if (value <= 0) return 0;
            return Math.log10(value) / Math.log10(maxVal);
        }
        
        // Get chaos class
        function getChaosClass(score) {
            if (score >= 42069) return 'fent';
            if (score > 1000) return 'heatdeath';
            if (score > 95) return 'apocalyptic';
            if (score > 80) return 'demonic';
            if (score > 60) return 'chaotic';
            if (score > 40) return 'active';
            return 'calm';
        }
        
        // Draw grid
        function drawGrid() {
            ctx.strokeStyle = '#112211';
            ctx.lineWidth = 1;
            const gridSize = 50;
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // Draw chaos regions
        function drawRegions() {
            const w = canvas.width;
            const h = canvas.height;
            
            // Calm region
            ctx.fillStyle = 'rgba(0, 255, 136, 0.05)';
            ctx.fillRect(0, h*0.8, w*0.2, h*0.2);
            
            // Active region
            ctx.fillStyle = 'rgba(255, 255, 0, 0.05)';
            ctx.fillRect(w*0.2, h*0.6, w*0.2, h*0.25);
            
            // Chaotic region
            ctx.fillStyle = 'rgba(255, 136, 0, 0.05)';
            ctx.fillRect(w*0.4, h*0.4, w*0.2, h*0.25);
            
            // Demonic region
            ctx.fillStyle = 'rgba(255, 0, 136, 0.05)';
            ctx.fillRect(w*0.6, h*0.2, w*0.2, h*0.25);
            
            // Apocalyptic region
            ctx.fillStyle = 'rgba(255, 0, 0, 0.05)';
            ctx.fillRect(w*0.8, 0, w*0.2, h*0.25);
        }
        
        // Draw trajectory
        function drawTrajectory() {
            if (trajectory.length < 2) return;
            
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < trajectory.length - 1; i++) {
                const p1 = trajectory[i];
                const p2 = trajectory[i + 1];
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
            ctx.stroke();
            
            // Draw points
            trajectory.forEach((p, i) => {
                const alpha = i / trajectory.length;
                ctx.fillStyle = `rgba(255, 0, 255, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Draw current position
        function drawCurrent(chaos, chat, door, pizza) {
            // Map to canvas (logarithmic for huge values)
            const x = Math.min(canvas.width * 0.9, Math.max(50, 50 + logScale(chat, 1000) * canvas.width * 0.8));
            const y = Math.min(canvas.height * 0.9, Math.max(50, canvas.height * 0.9 - logScale(pizza, 10000000000) * canvas.height * 0.8));
            
            // Add to trajectory
            trajectory.push({x, y, chaos, time: Date.now()});
            if (trajectory.length > maxPoints) trajectory.shift();
            
            // Draw current point
            const chaosClass = getChaosClass(chaos);
            let color = '#0f0';
            let radius = 8;
            
            switch(chaosClass) {
                case 'calm': color = '#0f0'; break;
                case 'active': color = '#ff0'; radius = 12; break;
                case 'chaotic': color = '#f80'; radius = 15; break;
                case 'demonic': color = '#f08'; radius = 18; break;
                case 'apocalyptic': color = '#f00'; radius = 22; break;
                case 'heatdeath': color = '#f0f'; radius = 26; break;
                case 'fent': color = '#0f0'; radius = 30; break;
            }
            
            // Glow effect
            ctx.shadowBlur = 20;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Label
            ctx.fillStyle = '#fff';
            ctx.font = '12px monospace';
            ctx.fillText(`‚ö°${chaos.toFixed(1)}`, x + 20, y);
        }
        
        // Main draw loop
        function draw() {
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            drawRegions();
            drawTrajectory();
            
            if (lastData) {
                drawCurrent(
                    lastData.chaos_score,
                    lastData.chat_velocity_5min,
                    lastData.door_events_10min,
                    lastData.pizza_count
                );
            }
        }
        
        // Update UI with metrics
        function updateUI(data) {
            const chaos = data.chaos_score;
            const chaosClass = getChaosClass(chaos);
            
            // Update metrics
            document.getElementById('chaosVal').textContent = chaos.toFixed(1);
            document.getElementById('chaosVal').className = 'metric-value ' + (chaosClass === 'fent' ? 'fent' : chaos > 80 ? 'flood' : '');
            document.getElementById('chat5Val').textContent = data.chat_velocity_5min;
            document.getElementById('door10Val').textContent = data.door_events_10min;
            document.getElementById('pizzaVal').textContent = data.pizza_count > 1000000 ? (data.pizza_count / 1000000).toFixed(1) + 'M' : data.pizza_count;
            document.getElementById('statusVal').textContent = data.status?.substring(0, 20) || 'Unknown';
            
            // Update chaos bar
            let barWidth = Math.min(100, (chaos / 100) * 100);
            if (chaos > 100) barWidth = 100; // Max out at 100 for visual
            document.getElementById('chaosBar').style.width = barWidth + '%';
            document.getElementById('chaosBar').className = 'bar-fill ' + chaosClass;
            document.getElementById('chaosBig').textContent = chaos.toFixed(1);
            
            // Calculate trajectory metrics
            if (trajectory.length > 1) {
                const recent = trajectory.slice(-5);
                const dx = recent[recent.length - 1].x - recent[0].x;
                const dy = recent[recent.length - 1].y - recent[0].y;
                const velocity = Math.sqrt(dx*dx + dy*dy);
                document.getElementById('velocityVal').textContent = velocity.toFixed(0) + ' px/min';
                
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                const arrow = angle > -45 && angle < 45 ? '‚Üí' : angle >= 45 && angle < 135 ? '‚Üì' : angle >= 135 || angle < -135 ? '‚Üê' : '‚Üë';
                document.getElementById('directionVal').textContent = arrow;
                
                // Flood risk assessment
                let risk = 'LOW';
                if (data.chat_velocity_5min > 50 || chaos > 80) risk = 'MEDIUM';
                if (data.chat_velocity_5min > 100 || chaos > 500) risk = 'HIGH';
                if (data.chat_velocity_5min > 500 || chaos > 1000) risk = 'EXTREME';
                document.getElementById('floodRiskVal').textContent = risk;
                document.getElementById('floodRiskVal').className = 'metric-value' + (risk !== 'LOW' ? ' flood' : '');
                
                // Time to Fenthouse (if not already)
                if (chaos < 42069) {
                    const needed = 42069 - chaos;
                    if (chaos < 0.1) document.getElementById('timeToFentVal').textContent = '‚àû';
                    else {
                        const rate = (trajectory[trajectory.length - 1].chaos - trajectory[0].chaos) / (trajectory.length);
                        if (rate > 0) {
                            const minutes = needed / rate / 12; // ~5 sec per update, 12 per min
                            document.getElementById('timeToFentVal').textContent = minutes.toFixed(1) + ' min';
                        } else {
                            document.getElementById('timeToFentVal').textContent = '‚àû';
                        }
                    }
                } else {
                    document.getElementById('timeToFentVal').textContent = 'üî• ACTIVE';
                }
            }
            
            // Flood alert
            const floodAlert = document.getElementById('floodAlert');
            if (data.chat_velocity_5min > 100 || chaos > 1000) {
                floodAlert.style.display = 'block';
            } else {
                floodAlert.style.display = 'none';
            }
        }
        
        // Fetch metrics
        async function updateMetrics() {
            try {
                const response = await fetch('/api/metrics');
                const data = await response.json();
                lastData = data;
                updateUI(data);
            } catch (err) {
                console.error('Metrics fetch failed:', err);
            }
        }
        
        // Animation loop
        function animate() {
            draw();
            requestAnimationFrame(animate);
        }
        
        // Start
        animate();
        updateMetrics();
        setInterval(updateMetrics, 5000);
    </script>
</body>
</html>